Дерево отрезков, ДО, Segment Tree
Для решения задач класса [[Запросы на отрезках (RMQ)]].

ДО (дерево отрезков) используется для подсчёта значения (например, суммы) на отрезке, изменения (например, добавления) на отрезке. Если изменять элементы не нужно, то можно использовать префиксную сумму вместо ДО.

Построение дерева.

Реализации.
Рекурсивные (сверху-вниз) и без рекурсии (снизу-вверх). Без рекурсии меньше кода, но рекурсия чуть понятее, и иногда без рекурсии нельзя (если нужен propagate)
Если рекурсивно, то обязательно x=0 (номер узла в t), lx=0, rx=N (границы отрезка узла):

По назначению. (Функции sum, add можно заменить на cac, change для любой операции из допустимых. "↑x" означает верхние узлы дерева):
1 . 1 . build, set, sum. t[↑x] = t[2x+1]∆t[2x+2]. Можем считать на отрезке и изменять значение узла.
set(i(индекс), v[, x(узел), lx, rx](границы узла)) {O(log N)}
sum(l, r[, x, lx, rx]) {O(log N)}. Только если операция ассоциативная, так как операнды это отрезки (т.е (a∆b)∆c = a∆(b∆c)) [+ * min max =].
1 . 2 . sum(l, r) {log (r–l)} (без рекурсии быстрее). Можно делать снизу-вверх только если операция коммутативная (x∆y = y∆x) (иначе сделать аккумулятор справа). Также при calc снизу-вверх lx rx это номера узлов, а не границы отрезка (т.е не lx ≤ … < rx, как везде в других случаях)
2 . build, add, get. t[↑x] = 0. Можем изменять значения узлов и считать значение одного.
get(i[, x, lx, rx]) {O(log N)}
add(l, r, v[, x, lx, rx]) {O(log N) или O(log (r–l))} Всё так же, но операции должны быть коммутативными. Чтобы это обойти, при добавлении операций [напр. =] в переходе вправо/влево надо делать propagate (при этом надо делать сверху-вниз) {for i=1..2 t[2x+i] ∆= t[x]; t[x] = Neutral∆   // именно t}
3 . build, change, calc. t[↑x] = t[2x+1] min t[2x+2]. Можем делать всё
Обе операции должны быть коммутативны в паре (a+c min b+c = (a min b) + c) [+min, +*, minmin, minmax; для +sum надо учитывать rx–lx]. Делать рекурсивно сверху-вниз, после строк 'change для детей вершины' пересчитывать значение этой вершины